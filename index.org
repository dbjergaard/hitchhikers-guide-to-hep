#+TITLE: A Hitchhiker's guide to High Energy Physics
#+AUTHOR: David Bjergaard
#+EMAIL: david.b@duke.edu

* DON'T PANIC
** Introduction
Welcome to High Energy Physics.  Like the Galaxy, HEP is a wonderful
and mysterious place filled with amazing things.  The intent of this
guide is to provide a jump-start to HEP research.  Its purpose is to
be entertaining and un-informative.  If you find the guide
educational, the editors kindly request that you send an edit which
suitably obfuscates what you found enlightening.  The road you are on
is one of enlightenment, and you can't be enlightened unless you are
first darkened.

If you find this guide next to useless and think it would be better
served as toilet paper in its printed form, then please send a bottle
of Old Janx Spirit to the editor of that section.

The Guide is not intended to be read linearly.  Jump to the section
you need, and if that section contains links to other sections, then
please see above regarding edits. 

*NOTE* If you are reading this on github, a link to another section
will probably be broken due to a bug in how github parses org-flavored
markdown.  It is better to open this guide in Emacs and follow links
with "C-c C-o".
*** Disclaimer
All bottles of donated Old Janx Spirit are redirected to our lawyers,
who are out enjoying them now.  They insisted that we include this
disclaimer:

#+BEGIN_QUOTE
The Hitchhiker's Guide to High Energy Physics is a set of documents
and software herein referred to as "The Guide"

The Guide is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

The Guide is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this software.  If not, see <http://www.gnu.org/licenses/>.
#+END_QUOTE

Also, note that the content of this guide is satirical in nature, and
is intended to be sarcastic. If you have a weak heart or are easily
offended, it may be better to seek out other sources of information.
** For Windows Hitchhikers
While it is possible to practice HEP from the comfort of Bill Gates'
brain child, it is not recommended by The Guide editors.  (They don't
run Windows anyway, daylight scares them.) If you insist on using
Windows, the following is a list of useful software.

Everyone should read [[*For%20Linux%20Hitchhikers][For Linux Hitchhikers]] to understand what
functionality they'll need (especially when working with or on remote
machines)
*** Software you will need
- [[*For%20Linux%20Hitchhikers][For Linux Hitchhikers]]
- [[http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html][PuTTY (ssh client for Windows)]]: Secure SHell is the standard way of
  accessing *nix machines remotely.  PuTTY is the Windows client for
  this. 
- ROOT (Not for the faint of heart)
- [[http://www.straightrunning.com/XmingNotes/][Xming an X11 server for Windows]]: This allows you to tunnel X11
  applications (ROOT's histogram interface) to your windows desktop,
  this way your data (and ROOT) can live on a remote machine, but you
  can still interact with them as if they were on your desktop.  (You
  need a *fast* internet connection to do this)
- [[https://github.com/bmatzelle/gow/wiki][Gow]]: A lightweight Cygwin alternative, this is probably for more
  adventurous hitchhikers only. 
- [[http://cygwin.com/][Cygwin]]: Adds a substrate of the gnu system to windows (in addition
  to an [[http://x.cygwin.com/][X11 server]]), you can use this 
- [[https://www.virtualbox.org/][VirtualBox]]: Allows you to boot operating systems within operating
  systems (useful if you don't want to dual boot Ubuntu) see [[*For%20Linux%20Hitchhikers][For Linux
  Hitchhikers]] after you've setup a working distro.

[[http://www.calebmadrigal.com/running-ubuntu-virtualbox/][See here]] for a nice picture-book tutorial on installing Ubuntu
through VirtualBox on windows.
** For Linux Hitchhikers
*** Software you will need
 - [[https://www.gnu.org/software/screen/][Screen]]: This lets you pick up where you left off if your ssh
   connection drops, [[http://www.ibm.com/developerworks/aix/library/au-gnu_screen/][here]] is a good conceptual introduction
 - [[http://root.cern.ch/drupal/content/installing-root-source][ROOT]]: The industry standard for High Energy Physics analysis.
   Beware: this program uses an [[https://en.wikipedia.org/wiki/Technology_in_The_Hitchhiker's_Guide_to_the_Galaxy#Infinite_Improbability_Drive][Infinite Improbability Drive]] to
   perform analysis.  
 - [[https://help.ubuntu.com/community/Beginners/BashScripting][BASH]]: The command shell of choice for ATLAS Physicists.  You may
   think you could use ZSH, but its better just to stick with
   what everyone else uses.  CMS Physicists prefer TCSH for some
   weird reason.
 - [[*Editors][Editor]]: Choose you're religion wisely, it will eventually permeate
   your being and change the way you approach life in general.
*** Configuring SSH
Many of these tips are [[http://blogs.perl.org/users/smylers/2011/08/ssh-productivity-tips.html][lifted from here]].
Put this in you're =~/.ssh/config= file:
#+BEGIN_EXAMPLE
ControlMaster auto
ControlPath /tmp/ssh_mux_%h_%p_%r
ControlPersist yes
TCPKeepAlive no
ServerAliveInterval 30
ServerAliveCountMax 1
#+END_EXAMPLE
It is possible to setup ssh shorthand to route you to remote
machines. The syntax (in =~/.ssh/config=) is:
#+BEGIN_EXAMPLE
Host shortname
  #expands to shortname.remote.location.edu
  HostName %h.remote.location.edu 
  User username
  ForwardX11 yes #this is equivalient to ssh -Y
  IdentityFile ~/.ssh/id_rsa #path to your pubkey
#+END_EXAMPLE
**** SSH Keys
[[https://help.github.com/articles/generating-ssh-keys][Follow this guide]], stop at step 3.
Now, when you need to start using a new machine:
#+BEGIN_EXAMPLE
ssh-copy-id user@remote.machine.name
#+END_EXAMPLE
Then enter your password.  Now, when you type =ssh
user@remote.machine.name= you will authenticate yourself with your
newly minted RSA key, and you won't have to enter your password.  The
downside is that you'll have to enter your key's passphrase to unlock
it. See below for a way to unlock it once per session.

*NOTE* While it is cryptographically more secure to authenticate
yourself with ssh keys, if your machine is compromised (ie stolen or
hacked) your ssh keys can provide the attacker with easier access to
all the machines you had access to.  This means you should:
1. Use a strong pass*phrase*, not password.  You need to maximize the 
   number of bits of entropy in your key in order to make it
   difficult to crack should the keys fall into enemy hands.  
2. Inform the Admins of any machines you had access to if your
   machine is compromised
3. Encrypt your ssh keys (and other sensitive information) in a
   private directory that only you can access
4. *NEVER EVER* store your ssh keys on a third party site (like
   Dropbox or similar services)
**** SSH Agent
If you have ssh-agent running (through the =gnome-keyring= service on
Ubuntu, or directly in your .xinitrc through =ssh-agent blah=) you
can type =ssh-add= when you log in and it will add your ssh key to
the keyring, then you can ssh to any machine that you have copied
your key to without entering the password! 

*NOTE* Once you've added your key to the ssh-agent, anyone can sit
down at your keyboard and log into a remote machine as you! This
means if you step away from your computer (even for a moment) you
should lock the screen or log out.  

*** Version Control Systems
The two major version control systems in HEP are Git and Subversion (svn).  These
are tools and utilities to allow collaboration on large pieces of
software.  

They also provide programmers with a convenient "paper trail" through
the course of developing a piece of software.  It allows them to
revert the source code they are working on to any state that they've
previously checked in.

Subversion is a successor of CVS, everything is stored on a remote
site, and your source code directory contains metadata about the
source code with reference to the remote site.  

Some subversion tutorials:
- [[https://www.clear.rice.edu/comp314/svn.html][Source Control in 10 Minutes ]]
- [[http://www.pointbeing.net/weblog/2009/03/command-line-subversion-tutorial-part-1.html][Command Line Subversion Tutorial (part 1)]]
- [[http://svnbook.red-bean.com/][Version Control with Subversion]] (A comprehensive free book about Subversion)

Git is a software that was written by Linus Torvalds, the hacker
behind Linux.  It was written to manage the Linux kernel, a massive
piece of software.  Git's model for managing source code is slightly
different.  In Git, you maintain the entire repository in your local
copy.  This makes committing, managing, and branching very fast.  It
also means you can work with all of the advantages of a version
control system without internet access.  Simultaneously there is a
copy of the repository on a remote server.  Git handles syncing these
two repositories when instructed.  This can lead to confusion if
you've used other versioning systems, but shouldn't be a problem if
you have no expectations.

Some good git tutorials:
- type "man gittutorial" in the command line
- [[http://git-scm.com/book][Pro Git]] (an online book, modular and comprehensive in scope)
- [[http://gitimmersion.com/][Git Immersion]]
- [[http://gitolite.com/gcs.html#%25281%2529][Git Concepts Simplified]] (slide show, click to advance)
Intermediate or advanced topics:
- [[http://sethrobertson.github.io/GitFixUm/fixup.html][Undoing, fixing, or removing commits in git]]
- [[https://blogs.atlassian.com/2014/01/simple-git-workflow-simple/][Simple Git workflow is simple]]
- [[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]

** For Mac OSX Hitchhikers
Everyone should read [[*For%20Linux%20Hitchhikers][For Linux Hitchhikers]] to understand what
functionality they'll need (especially when working with or on remote machines)
*** Software you will need
 - [[http://xquartz.macosforge.org/landing/][XQuartz]]: Like XMing for Windows, XQuartz runs a local X11 server
   for tunneling X11 applications over SSH, unlike Windows, you don't
   need a separate SSH program, ssh is built in.
 - [[https://en.wikipedia.org/wiki/Terminal_%2528OS_X%2529][Terminal.app]]: This is Mac OS's default terminal emulator. It comes
   with Mac OS, so you shouldn't need to install it.  You should be
   aware of it though.
 - [[http://aquamacs.org/][Aquamacs]]: A port of Emacs that uses Aqua as a standard OS X
   application. This integrates Emacs with the Mac OS UI.  In the
   long history of corporate acquisitions a lot of Emacs hackers (from
   NeXTSTEP) ended up at apple, you will find that Mac OS integrates
   the Emacs experience much more fundamentally than any other OS in
   existance. (This doesn't mean you need to use Emacs if you use Mac
   OS, just that your muscle memory will thank you subconsciously.)
 - [[https://www.macports.org/install.php][MacPorts]]: A system for compiling and installing open source
   software on the Mac
 - [[brew.sh][Home Brew]]: A package manager for Mac OS, allowing you to install
   various utilities that don't necessarily come pre-installed with
   Mac OS. 
** Editors
Like the major world religions, there are also major editors.  In
the *nix ecosystem there are two main editors, Emacs and vim. There are
others, but they are many, and beyond the scope of this guide.  

The most important thing to do after [[https://stackoverflow.com/questions/1430164/differences-between-Emacs-and-vim][choosing an editor]] is to work
through its corresponding tutorial.  An oft heard recommendation is
that "Emacs is easier to learn than vi(m)".  True enlightenment in
either of these editors is roughly the same after completing the
corresponding tutorial.  

*** Finding an editor Guru
After you have finished the tutorial for your editor of choice, then
its time to find a guru.  Guru's are best located by asking around.
If you are talking with someone and notice they use your editor,
don't be afraid to ask them how they did something. Most of the time
the Guru will be flattered and may even volunteer to help you with
any other editor related questions.  
**** Editor Guru etiquette
While it is generally OK to ask your Guru any editor related
question, it is best to keep questions restricted to the editor in
question.  Flame wars have been fought for decades over which is the
"one true editor." 

In order to prevent a faux pas, it is best to make sure you know which
editor your guru uses.  This is especially true in the case of a
vi(m) or Emacs guru. 

Another thing to be careful of is repeatedly asking basic questions.
Again, some gurus will tolerate this at the beginning, but after a
point the guru expects you to master the basics (on your own). The
most valuable knowledge your guru can impart is not written in the
tutorial that came with the editor.
**** Keeping your Guru happy
Guru's subsist mainly on a liquid diet of caffeinated beverages
during the day and beer (occasionally wine) at night.  It is
important that your Guru remain well lubricated. It is generally
considered a good gesture to offer your Guru his/her beverage of
choice if you've found him/her to be especially helpful on your path
to enlightenment. 
*** Emacs
The end goal of any student of the [[http://www.jwz.org/hacks/why-cooperation-with-rms-is-impossible.mp3][Church of Emacs]] is to obtain
proficiency reprogramming the editor to solve the task at hand.  This
is ultimately stems from the philosophy of lisp (this gift was given
to us by [[http://www.stallman.org/saint.html][St. IGNUcious]] an AI hacker from MIT where Emacs was born).
In lisp, the flexibility of the language allows it to be re-written to
solve the problem as clearly as possible.  In Emacs, an enlightened
user will write a substrate of elisp (Emacs' dialect of lisp) in order
to solve the editing problem at hand.

While customizing and writing your .emacs (the initialization file
loaded by Emacs in your home directory) is a spiritual journey, there
are those who have done their best to illuminate the path. [[http://www.dialectical-computing.de/blog/blog/2014/03/02/a-simple-emacs-configuration/][A brief
guide to customization philosophies here]].

The editor of this guide finds the following packages essential:
- [[info:tramp#Top][tramp]]: If your reading this in Emacs, you can follow the link with
  "C-c C-o". It is *the* most important aspect of Emacs for HEP
  users. It allows you to "visit" files on remote machines from the
  Emacs running on your desktop.  It does this through ssh.  To visit
  a remote file, type "C-x C-f" and then type
  '/ssh:user@remote.host:~/remote/path', note that tab completion
  works remotely just the same as visiting a file locally! Tramp is
  also aware of ssh alias setup, see [[*Configuring SSH]].
- filladapt: a mode for more intelligently filling text in paragraphs
- flyspell: a spell checker that highlights mispelled words (will check
  in comments if in a programming mode)
- rect-mark: Adds facilities for marking yanking and otherwise
  editing columnar formatted text. 
- dired: a directory editor for manipulating files in the Emacs way
- solarized-theme: A theme by Ethan Schoonover, comes in dark and
  light variants that actually complement each other well, another
  good one is zenburn 
- ibuffer: changes the buffer interface and allows you to group
  buffers based on various buffer attributes
- paredit: Enhances Emacs's awareness of parenthetic structure 
- smartparens: Electrically pairs and deletes delimeters when
  appropriate (never miss a closing brace again!)
- auto-complete: When setup properly, tab completes anything at any
  point depending on past input or names in other buffers.
- auctex: LaTeX editing facilities (for when org-mode doesn't quite cut
  it)
- org-mode: This guide is written in org-mode. Org-mode can manage
  [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][todo lists]], [[http://orgmode.org/worg/org-web.html][write websites]], serve as a [[http://www.phy.duke.edu/~dmb60/][lab notebook]], execute code
  for [[http://orgmode.org/worg/org-contrib/babel/][literate programming]] and many other things.  People switch to
  Emacs just to get org-mode! 

Init files of famous Emacs hackers are (in no order of awesomeness)
[[https://github.com/magnars/.emacs.d][Magnar Sveen]], [[https://github.com/technomancy/dotfiles/tree/master/.emacs.d][Technomancy]], [[https://github.com/jwiegley/dot-emacs][John Wiegley]].  There are also software
packages that intend to comprehensively change the Emacs out of the
box to a better user experience.  The two most famous are [[https://github.com/bbatsov/prelude][Prelude]] and
[[https://github.com/overtone/emacs-live][Emacs Live]]. An example (slightly annotated) init file can be found [[https://github.com/dbjergaard/dotfiles/blob/master/emacs-lisp/init.org][here]].

Finally, there are some Emacs gurus who post on the blogs on the
internet.  Some particularly useful ones are [[http://emacsredux.com/][Emacs Redux]], [[http://www.masteringemacs.org/][Mastering
Emacs]], and [[http://emacs-fu.blogspot.com/][Emacs Fu]]. 

Various religious texts granting Emacs users various powers (such as
reading email, chatting, tweeting, playing games, listening to music)
can be found at the [[http://www.emacswiki.org/emacs/][Emacs Wiki]]. 

*** Vim
If Emacs is like Catholicism, then Vim is like Buddhism.  Vim is
modern incarnation of vi, a modal text editor that descended from
ed.  The modal way of editing is by expressing in a few keystrokes
how the text should be manipulated.  This is in contrast to Emacs,
where text is manipulated directly.  This fundamental difference is
the source of much confusion for new users, and is also why many
people recommend Emacs as "being easier to learn." This should not
deter new users from learning vi(m), as its editing facilities are
substantial.

A functional =.vimrc= looks like:
#+BEGIN_EXAMPLE
syntax on
set cursorline
set hlsearch
set ic
set incsearch
set ruler
set shiftwidth=4
set tabstop=4
set wrap
#+END_EXAMPLE

To learn vim, type =vimtutor= at the command lime and follow the
instructions. Take your time, and repeat the tutorial once or twice
over a few days.  In the mean time editors such as =gedit= or =nano=
offer a more traditional experience.  As your vim skills improve, you
will feel more comfortable with vim and can stop using the less
powerful editors.  

Some useful links include:
- [[http://www.vimgenius.com/][Vim Genius]] a drill website for learning vim commands
- [[https://www.liquidweb.com/kb/overview-of-vim-text-editor/][New user Vim Tutorial]]
- [[http://blog.sanctum.geek.nz/vim-koans/][Vim Koans]] tidbits of wisdom to ponder
- [[http://www.vim.org/scripts/][A collection of extensions and plugins for vim]]
- [[http://val.markovic.io/blog/youcompleteme-a-fast-as-you-type-fuzzy-search-code-completion-engine-for-vim][YouCompleteMe]] A vim autocompletion engine for editing. 
*** Others
Followers of the UNIX way realize that there are situations where a
using a set of shell commands piped together may fit the task at hand
more efficiently than either of the other two editors.  Tools you
should be familiar with are:
- [[http://www.grymoire.com/Unix/Sed.html][sed]] and [[http://sed.sourceforge.net/sed1line.txt][one-liners]]
- [[http://www.grymoire.com/Unix/Awk.html][awk]] and [[http://www.pement.org/awk/awk1line.txt][one-liners]]
- [[http://perl-tutorial.org/][perl]] (and its [[https://en.wikipedia.org/wiki/Black_Perl][poetry]])
- [[http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/][grep]] 
[[http://regex.info/blog/2006-09-15/247][Always keep in mind]]
#+BEGIN_QUOTE
Some people, when confronted with a problem, think
"I know, I'll use regular expressions."   Now they have two
problems. -- Jaimie Zawinski
#+END_QUOTE

** A brief introduction to C++ 
C++ is the industry standard programming language for analysis in
HEP.  Even if you are fortunate enough to do most of your work in
Python, you will eventually be calling C++ code, and should
understand some core concepts in order to debug problems should they
arise.

Things to keep in mind: 
- This portion of the guide covers C++ at a high level.  Very little
  [[www.cplusplus.com/tutorial][specific syntax]] will be covered.  When you have a C++ question,
  google is your friend.
- When writing in any language, prefer that languages idioms.  Don't
  write python in C++, c in C++ or C++ in python.
- C++ is a vast language, however being familiar with its roots, c,
  is invaluable.
- If faced with a decision between learning C++ vs Python, prefer
  C++.  C++'s syntax is more rigid and requires more overhead.  Once
  you know C++, python is much easier to pick up.
- There's always an exception to the rule, just make sure its the
  right exception!

C++ is an imperative, object oriented language.  It started out as a
"C with classes" but has since bolted on significant language
features different from c.  Proficiency with C++ should be aimed
towards comfortable use of the template meta-programming features of
the language, although it is entirely possible to spend an entire
career writing C++ without exercising this feature (just read the ROOT
source code). 
*** Pointers
[[http://www.chiark.greenend.org.uk/~sgtatham/cdescent/][Required Reading: The Descent to C]]

As C++ has evolved from c, it retains parts of c's low level nature.
Part of this is the need to be explicit about managing memory
manually.  This is in stark contrast to languages such as Java or
Python where memory management is handled for the programmer.

A consequence of this is the ability to address specific cells of
memory (the smallest accessible unit, typically a byte).  An object
(=int=, =double=, =float=, =char=, =string=, etc) may span several
memory cells.  A pointer is the computer's representation of a memory
cell's location in memory, ie a memory address.  Ultimately the
programmer is interested in the data contained in the set of memory
cells "pointed to" by the pointer.  The act of retrieving this data is
called "/dereferencing/ a pointer".

As in physics, facility with manipulating pointers is best gained
through experience, however many analogies have been developed to ease
confusion.  One analogy is street addresses, A street address is a
sequence of numbers (the pointer) which instructs someone, a mailman
say, (the computer), how to find a specific location. Once at that
location, it is possible to manipulate objects located at that address
(deliver mail if your the mailman, break the mailbox if your a bored
teenager, knock on the door if you are a vacuum salesman etc).

Now some syntax:
#+BEGIN_SRC cpp
  Foo* bar = new Foo("Baz",42,"What is the question?");
  std::cout << "object bar lives at memory address:"<<bar<<std::endl;
  std::cout << "bar calculated a question to the answer to \"The Ultimate Question\" as "<<bar->TheAnswer()<<std::endl;
  std::cout <<"Another way to get the answer is: "<<(*bar).TheAnswer()<<std::endl;
#+END_SRC
Lots of interesting things have been introduced here.  Let's look at a
possible output of this program:
#+BEGIN_EXAMPLE
object bar lives at memory address: 0xd29ad0
bar calculated a question to the answer to "The Ultimate Question" as "What is 6x9?"
Another way to get the answer is: "What is 6x9?"
#+END_EXAMPLE
What happened? Let's look at the first line
#+BEGIN_SRC cpp
  Foo* bar = new Foo("Baz",42,"What is the question?");
#+END_SRC
=Foo*= is a pointer of type =Foo=. It's an address to a chunk of memory
that contains an instance of =Foo=.  
#+BEGIN_QUOTE
Question: Why does the compiler need to know that its a Foo type object at that address? 
#+END_QUOTE
#+BEGIN_QUOTE
Answer: Foo might fall across several memory cells, in which case the
compiler must know how many memory cells to move if you ask for the
bar+1 spot. In fact, in c there is a concept called the void*, a
type-less pointer that is an address to anything.  It is the
programmer's responsibility to cast the void* to the correct type.
#+END_QUOTE

OK, so we have a pointer to an object of type =Foo= called =bar=.
#+BEGIN_QUOTE
Question: What happens on the right hand side of the assignment operator (=)?
#+END_QUOTE
#+BEGIN_QUOTE
Answer: C++ reserves the keyword "new" for memory allocation.  The
"new" keyword takes a class constructor on the right hand side, and
returns a memory address on the left hand side.  This address gets
stored in the variable =bar=.  
#+END_QUOTE

Operationally, the "new" keyword allocates a chunk of memory to hold
the object on the right hand side, and returns a pointer to the
beginning of the chunk.  

What happens when we want to access the memory that the pointer points
to? There is another operation called "dereferencing" which goes to
the address pointed to and returns the object contained at that point
in memory.  Consider the following snippet:
#+BEGIN_SRC cpp
double* foo = new double(3.14159);
double pi = *foo;
std::cout <<"Pi is: "<<pi<<std::endl;
#+END_SRC
Here, a chunk of memory has the value 3.14159 written to it, then
that value is retrieved and stored in another location of memory
called =pi=.  That data is the written out the terminal by
=std::cout= and =std::endl=.

Now we can understand this line:
#+BEGIN_SRC cpp
  std::cout <<"Another way to get the answer is: "<<(*bar).TheAnswer()<<std::endl;
#+END_SRC
It means, retrieve the object pointed to by =bar=, and call the method
"=TheAnswer()=" on it.  Programmers abhor syntax that can easily get
them into trouble, so the language designers (of c) added a shorthand
for this kind of operation (the =->= operator):
#+BEGIN_SRC cpp
  Foo* bar=new Foo();
  if(bar->Value()==(*bar).Value()){
    std::cout<<"They're the same!"<<std::endl;
  }
#+END_SRC
Quiz: What will the output of this snippet be?

**** Why are pointer's useful at all?
Clever hitchhikers will notice that this appears to be a bunch of
bureaucratic mucking about with pointless details, most of the time it
is.  Since most of HEP deals with pointless details bureaucratically,
a lot of HEP code uses pointers.

To understand the real purpose of pointers, we must examine [[https://stackoverflow.com/questions/22146094/why-should-i-use-a-pointer-rather-than-the-object-itself?newsletter%3D1&nlcode%3D47931|9e27][dynamic
allocation]]. Consider the following code:
#+BEGIN_SRC cpp
  double* foo(){
    double* bar = new double(0.0);
  
    {
      double baz=42;
      *bar=baz;//dereference bar, and store the value of baz 
    }
    //baz is out of scope
    return bar;
  }
  int main(void){
    double* foobar=foo();
    std::cout <<"The Answer to the Ultimate question is :"<<*foobar<<std::endl;
    return 0;
  }
#+END_SRC
Let's execute the code in our mind:
1. execute =main(void)=
2. a =double*= named =foobar= is allocated.
3. =foo()= is executed
   1. a =double*= named =bar= is allocated
   2. new initializes a =double= with value 0.0
   3. new assigns the address containing that =double= to =bar=
   4. enter the braces, intialize a =double= named =baz= with value 42
   5. dereference =bar= and copy the value of =baz= into it
   6. exit the braces and free the memory where =baz= was
   7. return the address containing the value of =bar=;
4. Assign the value returned by =foo()= to =foobar=
5. stream the string "The Answer..." to stdout
6. dereference =*foobar= to obtain the value stored at =bar=, 42, stream
   that to stdout
7. add a newline to the output and flush the result to the terminal
   with =std::endl=
8. return 0
9. exit the program
**** References
A similar concept present in C++ (but not c) are references.  They can
be thought of as aliases (the way Dave is an alias of David). Their
syntax is:
#+BEGIN_SRC cpp
int foo=42;
int& theAnswer=foo;
foo=0;
std::cout<<theAnswer<<std::endl;
#+END_SRC
Here foo is initialized to the value 42, then a reference named
theAnswer is declared and assigned to foo.  All this does is make a
new name for the same object.  What does the program output?

The answer is 0.  References seem pointless (pun intended) until
they're used in function definitions:
#+BEGIN_SRC cpp
  void bar(int& foo){
    //complicated calculation for foo
    foo++;
  }
  int main(void){
    int baz=41;
    bar(baz);
    std::cout<<baz<<std::endl;
  }
#+END_SRC
#+BEGIN_QUOTE
Question: What is the output of this program?  
#+END_QUOTE
#+BEGIN_QUOTE
Answer: 42  
#+END_QUOTE

*** Methods
Methods, or functions are defined as:
#+BEGIN_SRC cpp
  return_type function_name(arg1_type arg1, arg2_type arg2, ...){
    //statements that define function_name
  }
#+END_SRC
It is possible to "forward declare" functions, these are "promises to
the compiler" that you have a function with a particular signature:
#+BEGIN_SRC cpp
  double foo(double,double);
  // important other stuff
  double foo(double theta, double phi){
    return sin(theta)*sin(theta) + cos(phi)*cos(phi);
  }
#+END_SRC
Notice that the compiler doesn't need to know the names of the
arguments in the forward declaration.  

Before we move onto the next topic, a note on methods.  Most of the
time during development, you only have a few helper functions.  This
is fine! Just write your helper functions in a header file, and
include them.  Write the main function and move on with your life.
There are many examples in HEP, where methods have been pigeon-holed
into classes.  The result is a cumbersome interface for the user
(YOU!) or more importantly your supervisor.  With that in mind, lets
move on to classes.
*** Classes
STOP! Read the last paragraph of the previous section.  

Now, ask yourself: Do I really need a class?  
No. Ok, great!

Yes. Are you sure?  Maybe your needs are better served with a few
functions and a well defined interface.

Do you have complicated data structures that need to be operated on
by many methods? No? Maybe your needs are better served with a few
functions and a well defined interface.

Yes? Maybe you should rethink your design.  

You've rethought it and realized that you have to use a class because
the person before you did, now there isn't a clean way to do it any
other way.  OK, classes.

The basic syntax is:
#+BEGIN_SRC cpp
  class A{
  public:
    A():a(0),b(0){};
    A(int _a):a(_a),b(0){};
    ~A(){};
    void SetA(int new_a){a=new_a;};
    void GetA(){return a;};
    void SetB(int new_b){b=new_b;};
    void GetB(){return b;};
  private:
    int a;
  protected:
    int b;
  };
#+END_SRC
This is a trivial example, and it breaks many rules about naming
conventions and clarity.  It is not a good example.  It should not be
used as a good example to win arguments about concise code.  In fact,
you probably shouldn't have read it.

Important features of the code: Anything after the public keyword is
accessible to the outside world, ie:
#+BEGIN_SRC cpp
A myObj;
myObj.SetA(10);
myObj.GetA();
myObj.SetB(42);
myObj.GetB();
#+END_SRC
Is all valid code, anything that is written after private, is just
that.  You cannot access it outside of the class:
#+BEGIN_SRC cpp
myObj.a; //Compiler error
myObj.b; //protected is a special form of private
#+END_SRC
The protected keyword is for class inheritance.  It says that these
variables and methods are private for users of the class, but if
another class inherits from this one, they inherit these symbols. 

Normally in class inheritance, you only inherit the public members of
the class.  The private members are not inherited.  Protected offers
a way to encapsulate data, but also share data among inheritance
diagrams.

In case you haven't picked up on it, classes are one of the hairier
aspects of C++.  Its better if you refer to some other resource for a
tutorial on classes, as their subtleties are beyond the scope of The
Guide.
** An even briefer introduction to Python
Python is a wonderful language.  It is expressive and allows rapid
prototyping with a shell type environment.  [[http://learnpythonthehardway.org/book/][Try learning it the hard
way]].  Another approach is to google what you're trying to do, and
make it run on a small test case.  

When writing code, it is best to be idiomatic.  This is especially
true in python.  Python's driving philosophy is "one right way" but
since python is being developed by multiple hackers, there are "many
right ways." 

- Here's an older tutorial on [[http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html][idiomatic python]].  
- [[http://safehammad.com/downloads/python-idioms-2014-01-16.pdf][A slideshow on idiomatic python]]
- [[https://en.wikibooks.org/wiki/Non-Programmer's_Tutorial_for_Python_3][A non-programmer's tutorial on python 3]] (also see the linked version
  for 2.7 as HEP is still using 2.7 or earlier in many cases)
- Finally, the [[http://docs.python.org/2/howto/doanddont.html][official recommendations]] for best practices.

** ROOT
For better or worse, for richer or poorer (always poorer), HEP
Physicists are married to (read: stuck with) ROOT.  Its the [[http://homes.cs.washington.edu/~weise/uhh-download.html][UNIX]] of
HEP.  There is method in the madness, though it is not clear what the
method is (just yet). 

ROOT is the industry standard tool for analyzing and manipulating
gobs of data.  Other statistical analysis tools [[http://www.matthewckeller.com/html/memory.html][crash and burn]] on the
datasets that ROOT eats for breakfast.  Without further ado, let's
set it up and get to work!
*** Installing and setting up
These instructions are for *nix based systems (ie it was written for
Ubuntu, but MacOS shouldn't be much different and Windows is out of
the question).

When choosing a version of ROOT, always pick the 'pro' (pro for
production) version.  Its the latest, stable, version recommended by
the ROOT Devs. 

*Nota Bene* If you're doing this on Mac OS, you'll need to use =brew
install blah= instead of =apt-get install blah=, and the package names
will probably be different. 

If you haven't yet, read the [[*For%20Linux%20Hitchhikers][section of the guide]] relevant to your OS.

For our install of ROOT, we'll be compiling and running it locally.
This has a few advantages:
- "Uninstalling" is easy, either unset the environment variables
  pointing to ROOT, or completely delete the folder that root lives
  in (in this example =~/root=)
- Having multiple versions side-by-side is possible, you could have:
  - =~/root-clang= a version of root compiled with clang
  - =~/root-5.34= a stable version of ROOT
  - =~/root-5.99= the beta version of ROOT 6
  - To use any of them you would just have to source
    =~/root-ver/bin/thisroot.sh=
- You don't need root (administrative) access on the machine (as long
  as the pre-req's are installed).  This is generally nice since it
  decouples ROOT from the hosting OS.  

**** Getting the Pre-Requisites
Now, all of the following information is documented at
[[root.cern.ch]], but it is even less organized than this guide. The
following is a straight-shot from no source code to a fully working
ROOT binary on a clean install of Ubuntu (currently 13.10, but the
build process has been stable for the last ~3 years)

End to end, this takes ~40min on a machine circa 2011, so budget some
coffee time.  

#+BEGIN_SRC sh
sudo apt-get install git dpkg-dev make g++ gcc binutils libx11-dev libxpm-dev \
        libxft-dev libxext-dev gfortran libssl-dev libpcre3-dev \
        xlibmesa-glu-dev libglew1.5-dev libftgl-dev \
        libmysqlclient-dev libfftw3-dev cfitsio-dev \
        graphviz-dev libavahi-compat-libdnssd-dev \
        libldap2-dev python-dev libxml2-dev libkrb5-dev \
        libgsl0-dev libqt4-dev
#+END_SRC
You may have some of these packages already if you've installed
=build-essential= or =git= before.  In either case, =apt= is smart
enough to see that and not re-install them. 

The above list of packages are for a full-blown,
all-features-enabled  version of ROOT.  If you want a stripped down
version, you'll have to get the pre-reqs from [[root.cern.ch]]. 

Let's get a copy of the source:
#+BEGIN_SRC sh
git clone http://root.cern.ch/git/root.git
#+END_SRC

For future reference, if you want to update:
#+BEGIN_SRC sh
git pull
git tag -l 
git checkout -b tag-name tag-name
#+END_SRC
=git tag -l= lists all the available tags, choose the one you want
and substitute it for =tag-name=

For now, lets checkout the latest pro branch:
#+BEGIN_SRC sh
git checkout -b v5-34-18 v5-34-18
#+END_SRC
This will checkout the branch =v5-34-18= to a local branch =v5-34-18=
and switch you to it. If you're new to "[[https://en.wikipedia.org/wiki/Version_control_systems][version control systems]]", or
"[[https://en.wikipedia.org/wiki/Source_code_management][source control management]]" then its useful to do a tutorial to learn
the basics.  In HEP, the major system used is called SVN, in open
source, git has become the de facto standard almost overnight.

With our code checked out and ready, we need to configure it to match
the computer we're compiling on.  To do this:
#+BEGIN_SRC sh
./configure --all 
#+END_SRC
To see all options run =./configure --help=, this command suggests
piping the output to =more=, but most "modern" terminal emulators have
a scroll-back buffer large enough that you can just scroll up and read
the output.  The =--all= option instructs configure to enable support
for as many packages as your system supports.  If you require a
specific feature (say roofit) you would type:
#+BEGIN_SRC sh
./configure [other options] --enable-roofit
#+END_SRC

If your interested in building ROOT with xrootd (network protocol
which allows opening root files over a network connection) see
[[*Advanced%20Build%20Options][Advanced Build Options]]. 

After configuring you should see:
#+BEGIN_EXAMPLE
Enabled support for asimage, astiff, builtin_afterimage, builtin_lzma, cintex, explicitlink, fftw3, fitsio, gviz, gdml, genvector, krb5, ldap, mathmore, memstat, minuit2, mysql, opengl, python, qt, qtgsi, reflex, roofit, shadowpw, shared, ssl, table, tmva, unuran, x11, xft, xml.

To build ROOT type:

   make 
#+END_EXAMPLE

Now type =make=:
#+BEGIN_SRC sh
make -j 4 
#+END_SRC
The =-j= option tells make how many jobs it can run simultaneously.
Without =-j=, only one job runs.  A good rule of thumb is to choose
the number of cores you have on your computer.  If you are compiling
on remote computer, it is probably shared by others, in which it is
good etiquette to run your jobs single threaded.  On your laptop, you
should choose *one less* than the number of cores you have (so you
don't notice a slow-down while its building in the background).

See =man make= and look under the option "-j [jobs]" for more
detailed information about this switch.

This will take (depending on your hardware) between 20-45min, so now
is a good time for a cup of tea, or coffee with your [[*Keeping%20your%20Guru%20happy][editor guru]].

When its finished, it will print out:
#+BEGIN_EXAMPLE
[lots of boring crap]

   ============================================================
   ===                ROOT BUILD SUCCESSFUL.                ===
   === Run 'source bin/thisroot.[c]sh' before starting ROOT ===
   ============================================================
#+END_EXAMPLE
If you do not get this message, but the build just ends with =[lots of
boring crap]= find a senior grad student and have them look at the
=[lots of boring crap]= (it won't be boring to them). They will be
able to instruct you on what went wrong. 

If you don't have a senior grad student handy, try googling some of
the output and seeing if you can get anywhere.  There is also the
[[http://root.cern.ch/phpBB3/viewforum.php?f%3D3&sid%3Db8e88bc1be4e5f599aedd95aeb047349][ROOT Talk Forums]].  

Now, when you want to use =root=, you can run the command:
#+BEGIN_SRC sh
source ~/root/bin/thisroot.sh
#+END_SRC
If you are using tcsh (you shouldn't be) you would need to run:
#+BEGIN_SRC sh
source ~/root/bin/thisroot.csh
#+END_SRC

There are differing opinions about whether or not you should put
something like this in your bashrc.  One school of thought (especially
applicable when you bounce between different versions) is that you
should keep your environment as clean as possible and only setup what
you need.  In that case adding:
#+BEGIN_SRC sh
alias setupROOT='source ${HOME}/root/bin/thisroot.sh'
#+END_SRC
To your =~/.bashrc= file is enough.

Then, whenever you need root, you have to run =setupROOT=, before you
can run =root=.

Another school of thought is that, you should always have some copy
of root available if possible.  In that case the following will
always setup root when bash runs if the setup file exists:
#+BEGIN_SRC sh
[ -f ~/root/bin/thisroot.sh ] && source ~/root/bin/thisroot.sh
#+END_SRC

Now you can start root by typing =root= at the command line.  You
should see:
#+BEGIN_EXAMPLE
  *******************************************
  *                                         *
  *        W E L C O M E  to  R O O T       *
  *                                         *
  *   Version   5.34/15  11 February 2014   *
  *                                         *
  *  You are welcome to visit our Web site  *
  *          http://root.cern.ch            *
  *                                         *
  *******************************************

ROOT 5.34/15 (v5-34-15@v5-34-15, Mar 21 2014, 14:04:01 on linuxx8664gcc)

CINT/ROOT C/C++ Interpreter version 5.18.00, July 2, 2010
Type ? for help. Commands must be C++ statements.
Enclose multiple statements between { }.
root [0]
#+END_EXAMPLE
To start root without the splash screen type =root -l= in which case
you see:
#+BEGIN_EXAMPLE
root [0]
#+END_EXAMPLE

*** A Path to ROOT enlightement
There are three methods of running code through ROOT to produce
results.  These methods are listed below, each more sophisticated
than the last.  They also include example code intended as a starting
point for hacking.   
**** Level 1: Macros
The first, and simplest way to execute ROOT related code is the
humble macro. A macro is a set of ROOT commands enclosed by
braces. For example:
#+BEGIN_SRC cpp
  {
    TFile* file= TFile::Open("MeaningOfLife.root");
    TH1F* hist = (TH1F*)file->Get("Hist1");
    cout << hist->GetNbinsX() <<endl;
  }
#+END_SRC

While not immediately obvious, ROOT macros are not written in C or
C++, but [[http://root.cern.ch/drupal/content/cint][CINT]]. CINT covers "most of"   ANSI C and ISO C++ 2003.
There are some important differences:
- =foo.blah= and =foo->blah= are interchangeable
- a semicolon ';' at the end of a line is optional
- No need to "=#include=" headers

As you progress in writing more sophisticated C++, you will run into
CINT's shortcomings as a C++ interpreter.  It is recommended that you
move to Level 2 or 3 before this happens. 

While it is possible to write complicated CINT macros (files with
multiple function definitions) it is not recommended.  CINT has a
habit of keeping up the appearance of doing one thing when in reality
something entirely different is happening "behind the scenes".

CINT is best used for quick scripts to plot histograms already saved
to a disk, or to inspect a few branches from a =TTree=.  More
sophisticated analyses are better served by Levels 2 and 3. 

**** Level 2: Compiled Macros
Compiled macros are full-blown C++ programs.  Generally there is a
"steering macro" that handles compiling and loading the required
libraries.  An example steering macro:
#+BEGIN_SRC cpp
{
  //may need to load other libraries or files that depend on analysis.C
  gROOT->ProcessLine(".L analysis.C++");
  gROOT->ProcessLine("doAnalysis()");
}
#+END_SRC


**** Level 3: Compiled Programs
**** A note on Enlightenment
*** PyROOT
*** Fitting Data with RooFit
*** Styling Plots 
*** Important Gotcha's 
**** TTrees
**** TH1
**** TH2
**** TFile
*** Debugging with ROOT
*** Advanced Build Options
[[http://root.cern.ch/drupal/content/installing-xrootd][Full instructions here]]

If you want to use xrootd, you'll also need cmake:
#+BEGIN_SRC sh
apt-get install cmake
#+END_SRC
Then, (from the directory where you checked out =root=):
#+BEGIN_SRC sh
./build/unix/installXrootd.sh 
#+END_SRC
This will install xrootd to whatever directory you're currently in,
so if you want it installed somewhere else, cd to that directory
first, just make sure that you update the location in the next command.

Now when you configure root you should use:
#+BEGIN_SRC sh
./configure --all --with-xrootd=${HOME}/root/xrootd-3.2.7/
#+END_SRC
Here =${HOME}/root/xrootd-3.2.7/ is the path where xrootd was
installed (based on the installXrootd.sh script above).  If you
blindly follow the instructions the above command will "just work".

*Nota Bene* The path following =--with-xrootd== must be a fully
qualified path (ie =/home/username/root/xrootd-3.2.7/=), the
configure script doesn't understand that =~/= is a shorthand for
=${HOME}=. 

if xrootd support has been enabled you should see:
#+BEGIN_EXAMPLE
Enabled support for asimage, astiff, builtin_afterimage, builtin_lzma, cintex, explicitlink, fftw3, fitsio, gviz, gdml, genvector, krb5, ldap, mathmore, memstat, minuit2, mysql, opengl, python, qt, qtgsi, reflex, roofit, shadowpw, shared, ssl, table, tmva, unuran, x11, xft, xml, xrootd.

To build ROOT type:

   make 
#+END_EXAMPLE

Make sure you see =xrootd= in the list! If not xrootd won't be
installed and won't function properly. You can now continue with the
[[*Installing%20and%20setting%20up][regular instructions]]

** Physics
*** Relativistic Mechanics
*** Mandelstam Variables
*** What to do if you've lost a 2\pi
Calm down, take a deep breath and read the first line of The Guide.
Then come back here.  Somewhere a fellow grad student has a copy of
"Introduction to Elementary Particles (2nd Edition)" by David
Griffiths.  Read Chapter 6 in entirety paying special note to the
footnote on page 205.  
** FAQ
