* DON'T PANIC
** A Hitchhiker's guide to High Energy Physics
** Introduction
Welcome to High Energy Physics.  Like the Galaxy, HEP is a wonderful
and mysterious place filled with amazing things.  The intent of this
guide is to provide a jump-start to HEP research.  Its purpose is to
be entertaining and un-informative.  If you find the guide
educational, the editors kindly request that you send an edit which
suitably obfuscates what you found enlightening.  The road you are on
is one of enlightenment, and you can't be enlightened unless you are
first darkened.

If you find this guide next to useless and think it would be better
served as toilet paper in its printed form, then please send a bottle
of Old Janx Spirit to the editor of that section.

The Guide is not intended to be read linearly.  Jump to the section
you need, and if that section contains links to other sections, then
please see above regarding edits. 

*NOTE* If you are reading this on github, a link to another section
will probably be broken due to a bug in how github parses org-flavored
markdown.  It is better to open this guide in Emacs and follow links
with "C-c C-o".
*** Disclaimer
All bottles of donated Old Janx Spirit are redirected to our lawyers,
who are out enjoying them now.  They insisted that we include this
disclaimer:
#+BEGIN_EXAMPLE
The Guide is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

The Guide is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this software.  If not, see <http://www.gnu.org/licenses/>.
#+END_EXAMPLE
Also, note that the content of this guide is satirical in nature, and
is intended to be sarcastic. If you have a weak heart or are easily
offended, it may be better to seek out other sources of information.
** For Windows Hitchhikers
While it is possible to practice HEP from the comfort of Bill Gates'
brain child, it is not recommended by The Guide editors.  (They don't
run Windows anyway, daylight scares them.) If you insist on using
Windows, the following is a list of useful software.
*** Software you will need
- [[*For%20Linux%20Hitchhikers][For Linux Hitchhikers]]
- [[http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html][PuTTY (ssh client for Windows)]]: Secure SHell is the standard way of
  accessing *nix machines remotely.  PuTTY is the Windows client for
  this. 
- ROOT (Not for the faint of heart)
- [[http://www.straightrunning.com/XmingNotes/][Xming an X11 server for Windows]]: This allows you to tunnel X11
  applications (ROOT's histogram interface) to your windows desktop,
  this way your data (and ROOT) can live on a remote machine, but you
  can still interact with them as if they were on your desktop.  (You
  need a *fast* internet connection to do this)
- [[https://github.com/bmatzelle/gow/wiki][Gow]]: A lightweight Cygwin alternative, this is probably for more
  adventurous hitchhikers only. 
- [[http://cygwin.com/][Cygwin]]: Adds a substrate of the gnu system to windows (in addition
  to an [[http://x.cygwin.com/][X11 server]]), you can use this 
- [[https://www.virtualbox.org/][VirtualBox]]: Allows you to boot operating systems within operating
  systems (useful if you don't want to dual boot Ubuntu) see [[*For%20Linux%20Hitchhikers][For Linux
  Hitchhikers]] after you've setup a working distro.

[[http://www.calebmadrigal.com/running-ubuntu-virtualbox/][See here]] for a nice picture-book tutorial on installing Ubuntu
through VirtualBox on windows.
** For Linux Hitchhikers
*** Software you will need
 - [[https://www.gnu.org/software/screen/][Screen]]: This lets you pick up where you left off if your ssh
   connection drops, [[http://www.ibm.com/developerworks/aix/library/au-gnu_screen/][here]] is a good conceptual introduction
 - [[http://root.cern.ch/drupal/content/installing-root-source][ROOT]]: The industry standard for High Energy Physics analysis.
   Beware: this program uses an [[https://en.wikipedia.org/wiki/Technology_in_The_Hitchhiker's_Guide_to_the_Galaxy#Infinite_Improbability_Drive][Infinite Improbability Drive]] to
   perform analysis.  
 - [[https://help.ubuntu.com/community/Beginners/BashScripting][BASH]]: The command shell of choice for ATLAS Physicists.  You may
   think you could use ZSH, but its better just to stick with
   what everyone else uses.  CMS Physicists prefer TCSH for some
   weird reason.
 - [[*Editors][Editor]]: Choose you're religion wisely, it will eventually permeate
   your being and change the way you approach life in general.
*** Configuring SSH
Many of these tips are [[http://blogs.perl.org/users/smylers/2011/08/ssh-productivity-tips.html][lifted from here]].
Put this in you're =~/.ssh/config= file:
#+BEGIN_EXAMPLE
ControlMaster auto
ControlPath /tmp/ssh_mux_%h_%p_%r
ControlPersist yes
TCPKeepAlive no
ServerAliveInterval 30
ServerAliveCountMax 1
#+END_EXAMPLE
It is possible to setup ssh shorthand to route you to remote
machines. The syntax (in =~/.ssh/config=) is:
#+BEGIN_EXAMPLE
Host shortname
  #expands to shortname.remote.location.edu
  HostName %h.remote.location.edu 
  User username
  ForwardX11 yes #this is equivalient to ssh -Y
  IdentityFile ~/.ssh/id_rsa #path to your pubkey
#+END_EXAMPLE
**** SSH Keys
[[https://help.github.com/articles/generating-ssh-keys][Follow this guide]], stop at step 3.
Now, when you need to start using a new machine:
#+BEGIN_EXAMPLE
ssh-copy-id user@remote.machine.name
#+END_EXAMPLE
Then enter your password.  Now, when you type =ssh
user@remote.machine.name= you will authenticate yourself with your
newly minted RSA key, and you won't have to enter your password.  The
downside is that you'll have to enter your key's passphrase to unlock
it. See below for a way to unlock it once per session.

*NOTE* While it is cryptographically more secure to authenticate
yourself with ssh keys, if your machine is compromised (ie stolen or
hacked) your ssh keys can provide the attacker with easier access to
all the machines you had access to.  This means you should:
1. Use a strong pass*phrase*, not password.  You need to maximize the 
   number of bits of entropy in your key in order to make it
   difficult to crack should the keys fall into enemy hands.  
2. Inform the Admins of any machines you had access to if your
   machine is compromised
3. Encrypt your ssh keys (and other sensitive information) in a
   private directory that only you can access
4. *NEVER EVER* store your ssh keys on a third party site (like
   Dropbox or similar services)
**** SSH Agent
If you have ssh-agent running (through the =gnome-keyring= service on
Ubuntu, or directly in your .xinitrc through =ssh-agent blah=) you
can type =ssh-add= when you log in and it will add your ssh key to
the keyring, then you can ssh to any machine that you have copied
your key to without entering the password! 

*NOTE* Once you've added your key to the ssh-agent, anyone can sit
down at your keyboard and log into a remote machine as you! This
means if you step away from your computer (even for a moment) you
should lock the screen or log out.  

** For Mac OSX Hitchhikers
*** Software you will need
 - [[http://xquartz.macosforge.org/landing/][XQuartz]]: Like XMing for Windows, XQuartz runs a local X11 server
   for tunneling X11 applications over SSH, unlike Windows, you don't
   need a separate SSH program, ssh is built in.
 - [[https://en.wikipedia.org/wiki/Terminal_%2528OS_X%2529][Terminal.app]]: This is Mac OS's default terminal emulator. It comes
   with Mac OS, so you shouldn't need to install it.  You should be
   aware of it though.
 - [[http://aquamacs.org/][Aquamacs]]: A port of Emacs that uses Aqua as a standard OS X
   application. This integrates Emacs with the Mac OS UI.  In the
   long history of corporate acquisitions a lot of Emacs hackers (from
   NeXTSTEP) ended up at apple, you will find that Mac OS integrates
   the Emacs experience much more fundamentally than any other OS in
   existance. (This doesn't mean you need to use Emacs if you use Mac
   OS, just that your muscle memory will thank you subconsciously.)
** Editors
Like the major world religions, there are also major editors.  In
the *nix ecosystem there are two main editors, Emacs and vim. There are
others, but they are many, and beyond the scope of this guide.  

The most important thing to do after [[https://stackoverflow.com/questions/1430164/differences-between-Emacs-and-vim][choosing an editor]] is to work
through its corresponding tutorial.  An oft heard recommendation is
that "Emacs is easier to learn than vi(m)".  True enlightenment in
either of these editors is roughly the same after completing the
corresponding tutorial.  

*** Finding an editor Guru
After you have finished the tutorial for your editor of choice, then
its time to find a guru.  Guru's are best located by asking around.
If you are talking with someone and notice they use your editor,
don't be afraid to ask them how they did something. Most of the time
the Guru will be flattered and may even volunteer to help you with
any other editor related questions.  
**** Editor Guru etiquette
While it is generally OK to ask your Guru any editor related
question, it is best to keep questions restricted to the editor in
question.  Flame wars have been fought for decades over which is the
"one true editor." 

In order to prevent a faux pas, it is best to make sure you know which
editor your guru uses.  This is especially true in the case of a
vi(m) or Emacs guru. 

Another thing to be careful of is repeatedly asking basic questions.
Again, some gurus will tolerate this at the beginning, but after a
point the guru expects you to master the basics (on your own). The
most valuable knowledge your guru can impart is not written in the
tutorial that came with the editor.
**** Keeping your Guru happy
Guru's subsist mainly on a liquid diet of caffeinated beverages
during the day and beer (occasionally wine) at night.  It is
important that your Guru remain well lubricated. It is generally
considered a good gesture to offer your Guru his/her beverage of
choice if you've found him/her to be especially helpful on your path
to enlightenment. 
*** Emacs
The end goal of any student of the [[http://www.jwz.org/hacks/why-cooperation-with-rms-is-impossible.mp3][Church of Emacs]] is to obtain
proficiency reprogramming the editor to solve the task at hand.  This
is ultimately stems from the philosophy of lisp (this gift was given
to us by [[http://www.stallman.org/saint.html][St. IGNUcious]] an AI hacker from MIT where Emacs was born).
In lisp, the flexibility of the language allows it to be re-written to
solve the problem as clearly as possible.  In Emacs, an enlightened
user will write a substrate of elisp (Emacs' dialect of lisp) in order
to solve the editing problem at hand.

While customizing and writing your .emacs (the initialization file
loaded by Emacs in your home directory) is a spiritual journey, there
are those who have done their best to illuminate the path. [[http://www.dialectical-computing.de/blog/blog/2014/03/02/a-simple-emacs-configuration/][A brief
guide to customization philosophies here]].

The editor of this guide finds the following packages essential:
- [[info:tramp#Top][tramp]]: If your reading this in Emacs, you can follow the link with
  "C-c C-o". It is *the* most important aspect of Emacs for HEP
  users. It allows you to "visit" files on remote machines from the
  Emacs running on your desktop.  It does this through ssh.  To visit
  a remote file, type "C-x C-f" and then type
  '/ssh:user@remote.host:~/remote/path', note that tab completion
  works remotely just the same as visiting a file locally! Tramp is
  also aware of ssh alias setup, see [[*Configuring SSH]].
- filladapt: a mode for more intelligently filling text in paragraphs
- flyspell: a spell checker that highlights mispelled words (will check
  in comments if in a programming mode)
- rect-mark: Adds facilities for marking yanking and otherwise
  editing columnar formatted text. 
- dired: a directory editor for manipulating files in the Emacs way
- solarized-theme: A theme by Ethan Schoonover, comes in dark and
  light variants that actually complement each other well, another
  good one is zenburn 
- ibuffer: changes the buffer interface and allows you to group
  buffers based on various buffer attributes
- paredit: Enhances Emacs's awareness of parenthetic structure 
- smartparens: Electrically pairs and deletes delimeters when
  appropriate (never miss a closing brace again!)
- auto-complete: When setup properly, tab completes anything at any
  point depending on past input or names in other buffers.
- auctex: LaTeX editing facilities (for when org-mode doesn't quite cut
  it)
- org-mode: This guide is written in org-mode. Org-mode can manage
  [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][todo lists]], [[http://orgmode.org/worg/org-web.html][write websites]], serve as a [[http://www.phy.duke.edu/~dmb60/][lab notebook]], execute code
  for [[http://orgmode.org/worg/org-contrib/babel/][literate programming]] and many other things.  People switch to
  Emacs just to get org-mode! 

Init files of famous Emacs hackers are (in no order of awesomeness)
[[https://github.com/magnars/.emacs.d][Magnar Sveen]], [[https://github.com/technomancy/dotfiles/tree/master/.emacs.d][Technomancy]], [[https://github.com/jwiegley/dot-emacs][John Wiegley]].  There are also software
packages that intend to comprehensively change the Emacs out of the
box to a better user experience.  The two most famous are [[https://github.com/bbatsov/prelude][Prelude]] and
[[https://github.com/overtone/emacs-live][Emacs Live]]. An example (slightly annotated) init file can be found [[https://github.com/dbjergaard/dotfiles/blob/master/emacs-lisp/init.org][here]].

Finally, there are some Emacs gurus who post on the blogs on the
internet.  Some particularly useful ones are [[http://emacsredux.com/][Emacs Redux]], [[http://www.masteringemacs.org/][Mastering
Emacs]], and [[http://emacs-fu.blogspot.com/][Emacs Fu]]. 

Various religious texts granting Emacs users various powers (such as
reading email, chatting, tweeting, playing games, listening to music)
can be found at the [[http://www.emacswiki.org/emacs/][Emacs Wiki]]. 

*** Vim
If Emacs is like Catholicism, then Vim is like Buddhism.  Vim is
modern incarnation of vi, a modal text editor that descended from
ed.  The modal way of editing is by expressing in a few keystrokes
how the text should be manipulated.  This is in contrast to Emacs,
where text is manipulated directly.  This fundamental difference is
the source of much confusion for new users, and is also why many
people recommend Emacs as "being easier to learn." This should not
deter new users from learning vi(m), as its editing facilities are
substantial.

A functional =.vimrc= looks like:
#+BEGIN_EXAMPLE
syntax on
set cursorline
set hlsearch
set ic
set incsearch
set ruler
set shiftwidth=4
set tabstop=4
set wrap
#+END_EXAMPLE

To learn vim, type =vimtutor= at the command lime and follow the
instructions. Take your time, and repeat the tutorial once or twice
over a few days.  In the mean time editors such as =gedit= or =nano=
offer a more traditional experience.  As your vim skills improve, you
will feel more comfortable with vim and can stop using the less
powerful editors.  

Some useful links include:
- [[http://www.vimgenius.com/][Vim Genius]] a drill website for learning vim commands
- [[https://www.liquidweb.com/kb/overview-of-vim-text-editor/][New user Vim Tutorial]]
- [[http://blog.sanctum.geek.nz/vim-koans/][Vim Koans]] tidbits of wisdom to ponder
- [[http://www.vim.org/scripts/][A collection of extensions and plugins for vim]]
- [[http://val.markovic.io/blog/youcompleteme-a-fast-as-you-type-fuzzy-search-code-completion-engine-for-vim][YouCompleteMe]] A vim autocompletion engine for editing. 
*** Others
Followers of the UNIX way realize that there are situations where a
using a set of shell commands piped together may fit the task at hand
more efficiently than either of the other two editors.  Tools you
should be familiar with are:
- [[http://www.grymoire.com/Unix/Sed.html][sed]] and [[http://sed.sourceforge.net/sed1line.txt][one-liners]]
- [[http://www.grymoire.com/Unix/Awk.html][awk]] and [[http://www.pement.org/awk/awk1line.txt][one-liners]]
- [[http://perl-tutorial.org/][perl]] (and its [[https://en.wikipedia.org/wiki/Black_Perl][poetry]])
- [[http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/][grep]] 
[[http://regex.info/blog/2006-09-15/247][Always keep in mind]]
#+BEGIN_QUOTE
Some people, when confronted with a problem, think
"I know, I'll use regular expressions."   Now they have two
problems. -- Jaimie Zawinski
#+END_QUOTE

** A brief introduction to C++ 
C++ is the industry standard programming language for analysis in
HEP.  Even if you are fortunate enough to do most of your work in
Python, you will eventually be calling C++ code, and should
understand some core concepts in order to debug problems should they
arise.

Things to keep in mind: 
- This portion of the guide covers C++ at a high level.  Very little
  [[www.cplusplus.com/tutorial][specific syntax]] will be covered.  When you have a C++ question,
  google is your friend.
- When writing in any language, prefer that languages idioms.  Don't
  write python in C++, c in C++ or C++ in python.
- C++ is a vast language, however being familiar with its roots, c,
  is invaluable.
- If faced with a decision between learning C++ vs Python, prefer
  C++.  C++'s syntax is more rigid and requires more overhead.  Once
  you know C++, python is much easier to pick up.  

C++ is an imperative, object oriented language.  It started out as a
"C with classes" but has since bolted on significant language
features different from c.  Proficiency with C++ should be aimed
towards comfortable use of the template meta-programming features of
the language, although it is entirely possible to spend an entire
career writing C++ without exercising this feature (just read the ROOT
source code). 
*** Pointers
[[http://www.chiark.greenend.org.uk/~sgtatham/cdescent/][Required Reading: The Descent to C]]

As C++ has evolved from c, it retains parts of c's low level nature.
Part of this is the need to be explicit about managing memory
manually.  This is in stark contrast to languages such as Java or
Python where memory management is handled for the programmer.

A consequence of this is the ability to address specific registers of
memory (the smallest accessible unit).  An object (int, double, float,
char, string, etc)  may span several registers.  A pointer is simply
the computers representation of a registers location in memory, ie a
memory address.  Ultimately the programmer is interested in the data
contained in the set of registers "pointed to" by the pointer.  The
act of retrieving this data is called "dereferencing a pointer".  

As in physics, facility with manipulating pointers is best gained
through experience, however many analogies have been developed to ease
confusion.  One analogy are street addresses, A street address is a
sequence of numbers (the pointer) which instructs a visitor, (a mailman
say) which is the computer in a labored sense, how to find a specific
location. Once at that location, it is possible to manipulate objects
located at that address (deliver mail if your the mailman, break the
mailbox if your a bored teenager, knock on the door if you are a
vacuum salesman etc). 

Now some syntax:
#+BEGIN_SRC cpp
  Foo* bar = new Foo("Baz",42,"What is the question?");
  std::cout << "object bar lives at memory address:"<<bar<<std::endl;
  std::cout << "bar calculated a question to the answer to \"The Ultimate Question\" as "<<bar->TheAnswer()<<std::endl;
  std::cout <<"Another way to get the answer is: "<<(*bar).TheAnswer()<<std::endl;
#+END_SRC
Lots of interesting syntax has been introduced here.  Lets look at a
possible output of this program:
#+BEGIN_EXAMPLE
object bar lives at memory address: 0xd29ad0
bar calculated a question to the answer to "The Ultimate Question" as "What is 6x9?"
Another way to get the answer is: "What is 6x9?"
#+END_EXAMPLE
What happened? Lets look at the first line
#+BEGIN_SRC cpp
  Foo* bar = new Foo("Baz",42,"What is the question?");
#+END_SRC
=Foo*= is a pointer of type Foo. Its an address to a chunk of memory
that contains an instance of Foo.  
#+BEGIN_QUOTE
Question: Why does the compiler need to know that its a Foo type object at that address? 
#+END_QUOTE
#+BEGIN_QUOTE
Answer: Foo might fall across several registers, in which case the
compiler must know how many registers to move if you ask for the
bar+1 spot. In fact, in c there is a concept called the void*, a
type-less pointer that is an address to anything.  It is the
programmers responsibility to cast the void* to the correct type.
#+END_QUOTE

OK, so we have a pointer to an object of type =Foo= called =bar=,
what happens on the right hand side of the assignment operator (=)?
Well, C++ reserves the keyword "new" for memory allocation.  The
"new" keyword takes a class constructor on the right hand side, and
returns a memory address on the left hand side.  This address gets
stored in the variable =bar=.  

Operationally, the "new" keyword allocates a chunk of memory to hold
the object on the right hand side, and returns a pointer to the
beginning of the chunk.  

What happens when we want to access the memory that the pointer points
to? There is another operation called "dereferencing" which goes to
the address pointed to and returns the object contained at that point
in memory.  Consider the following snippet:
#+BEGIN_SRC cpp
double* foo = new double(3.14159);
double pi = *foo;
std::cout <<"Pi is: "<<pi<<std::endl;
#+END_SRC
Now we can understand this line:
#+BEGIN_SRC cpp
  std::cout <<"Another way to get the answer is: "<<(*bar).TheAnswer()<<std::endl;
#+END_SRC
As, retrieve the object pointed to by bar, and call the method
"=TheAnswer()=" on it.  Programmers abhor syntax that can easily get
them into trouble, so the language designers (of c) added a shorthand
for this kind of operation:
#+BEGIN_SRC cpp
  Foo* bar=new Foo();
  if(bar->Value()==(*bar).Value()){
    std::cout<<"They're the same!"<<std::endl;
  }
#+END_SRC
Quiz: What will the output of this snippet be?

Clever hitchhikers will notice that this appears to be a bunch of
bureaucratic mucking about with pointless details, most of the time
it is.  Also, since most of HEP deals with pointless details
bureaucratically, a lot of HEP code uses pointers.

To understand the real purpose of pointers, we must examine [[https://stackoverflow.com/questions/22146094/why-should-i-use-a-pointer-rather-than-the-object-itself?newsletter%3D1&nlcode%3D47931|9e27][dynamic vs
static scoping]]. Consider the following code:
#+BEGIN_SRC cpp
  double* foo(){
    double* bar = new double(0.0);
  
    {
      double baz=42;
      *bar=baz;//dereference bar, and store the value of baz 
    }
    //baz is out of scope
    return bar;
  }
  int main(void){
    double* foobar=foo();
    std::cout <<"The Answer to the Ultimate question is :"<<*foobar<<std::endl;
    return 0;
  }
#+END_SRC
Let's execute the code in our mind:
1. a =double*= named foobar is allocated.
2. foo() is executed
   1. a =double*= named bar is allocated
   2. new initializes a double with value 0.0
   3. new assigns the address containing that double to bar
   4. enter the braces, intialize a double named baz with value 42
   5. dereference bar and copy the value of baz into it
   6. exit the braces and free the memory where baz was
   7. return the address containing the value of bar;
3. Assign the value returned by foo() to foobar
4. stream the string "The Answer..." to stdout
5. dereference *foobar to obtain the value stored at bar, 42, stream
   that to stdout
6. add a newline to the output and flush the result to the terminal
7. return 0
8. exit the program
**** References
A similar concept present in C++ (but not c) are references.  They
can be thought of as aliases. Their syntax is:
#+BEGIN_SRC cpp
int foo=42;
int& theAnswer=foo;
foo=0;
std::cout<<theAnswer<<std::endl;
#+END_SRC
Here foo is initialized to the value 42, then a reference named
theAnswer is declared and assigned to foo.  All this does is make a
new name for the same object.  What does the program output?

The answer is 0.  References seem pointless until they're used in
function definitions:
#+BEGIN_SRC cpp
  void bar(int& foo){
    //complicated calculation for foo
    foo++;
  }
  int main(void){
    int baz=0;
    bar(baz);
    std::cout<<baz<<std::endl;
  }
#+END_SRC
What is the output of this program?  

The answer is 1.  
*** Methods
Methods, or functions are defined as:
#+BEGIN_SRC cpp
  return_type function_name(arg1_type arg1, arg2_type arg2, ...){
    //statements that define function_name
  }
#+END_SRC
It is possible to "forward declare" functions, these are "promises to
the compiler" that you have a function with a particular signature:
#+BEGIN_SRC cpp
  double foo(double,double);
  // important other stuff
  double foo(double theta, double phi){
    return sin(theta)*sin(theta) + cos(phi)*cos(phi);
  }
#+END_SRC
Notice that the compiler doesn't need to know the names of the
arguments in the forward declaration.  

Before we move onto the next topic, a note on methods.  Most of the
time during development, you only have a few helper functions.  This
is fine! Just write your helper functions in a header file, and
include them.  Write the main function and move on with your life.
There are many examples in HEP, where methods have been pigeon-holed
into classes.  The result is a cumbersome interface for the user
(YOU!) or more importantly your supervisor.  With that in mind, lets
move on to classes.
*** Classes
STOP! Read the last paragraph of the previous section.  

Now, ask yourself: Do I really need a class?  
No. Ok, great!

Yes. Are you sure?  Maybe your needs are better served with a few
functions and a well defined interface.

Do you have complicated data structures that need to be operated on
by many methods? No? Maybe your needs are better served with a few
functions and a well defined interface.

Yes? Maybe you should rethink your design.  

You've rethought it and realized that you have to use a class because
the person before you did, now there isn't a clean way to do it any
other way.  OK, classes.

The basic syntax is:
#+BEGIN_SRC cpp
  class A{
  public:
    A():a(0),b(0){};
    A(int _a):a(_a),b(0){};
    ~A(){};
    void SetA(int new_a){a=new_a;};
    void GetA(){return a;};
    void SetB(int new_b){b=new_b;};
    void GetB(){return b;};
  private:
    int a;
  protected:
    int b;
  };
#+END_SRC
This is a trivial example, and it breaks many rules about naming
conventions and clarity.  It is not a good example.  It should not be
used as a good example to win arguments about concise code.  In fact,
you probably shouldn't have read it.

Important features of the code: Anything after the public keyword is
accessible to the outside world, ie:
#+BEGIN_SRC cpp
A myObj;
myObj.SetA(10);
myObj.GetA();
myObj.SetB(42);
myObj.GetB();
#+END_SRC
Is all valid code, anything that is written after private, is just
that.  You cannot access it outside of the class:
#+BEGIN_SRC cpp
myObj.a; //Compiler error
myObj.b; //protected is a special form of private
#+END_SRC
The protected keyword is for class inheritance.  It says that these
variables and methods are private for users of the class, but if
another class inherits from this one, they inherit these symbols. 

Normally in class inheritance, you only inherit the public members of
the class.  The private members are not inherited.  Protected offers
a way to encapsulate data, but also share data among inheritance
diagrams.

In case you haven't picked up on it, classes are one of the hairier
aspects of C++.  Its better if you refer to some other resource for a
tutorial on classes, as their subtleties are beyond the scope of The
Guide.
** An even briefer introduction to Python
Python is a wonderful language.  It is expressive and allows rapid
prototyping with a shell type environment.  [[http://learnpythonthehardway.org/book/][Try learning it the hard
way]].  Another approach is to google what you're trying to do, and
make it run on a small test case.  

When writing code, it is best to be idiomatic.  This is especially
true in python.  Python's driving philosophy is "one right way" but
since python is being developed by multiple hackers, there are "many
right ways." 

- Here's an older tutorial on [[http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html][idiomatic python]].  
- [[http://safehammad.com/downloads/python-idioms-2014-01-16.pdf][A slideshow on idiomatic python]]
- [[https://en.wikibooks.org/wiki/Non-Programmer's_Tutorial_for_Python_3][A non-programmer's tutorial on python 3]] (also see the linked version
  for 2.7 as HEP is still using 2.7 or earlier in many cases)
- Finally, the [[http://docs.python.org/2/howto/doanddont.html][official recommendations]] for best practices.

** Root
*** Installing and setting up
*** A Path to ROOT enlightement
**** Level 1: Macros
**** Level 2: Compiled Macors
**** Level 3: Compiled Programs
**** A note on Enlightenment
*** PyROOT
*** Fitting Data with RooFit
*** Styling Plots 
*** Important Gotcha's 
*** Debugging with ROOT
** Physics
*** Relativistic Mechanics
*** Mandelstam Variables
*** What to do if you've lost a 2\pi
Calm down, take a deep breath and read the first line of The Guide.
Then come back here.  Somewhere a fellow grad student has a copy of
"Introduction to Elementary Particles (2nd Edition)" by David
Griffiths.  Read Chapter 6 in entirety paying special note to the
footnote on page 205.  
** FAQ
